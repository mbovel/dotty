name: Benchmarks

on:
  pull_request:
    types:
      - closed # Triggered when a PR is merged
  schedule:
    - cron: "11 1 * * *" # Every night at 01:11 UTC
  workflow_call:
    inputs:
      commit:
        description: "Commit to benchmark."
        required: true
        type: string
      repo:
        description: "GitHub repository containing the commit to benchmark."
        required: true
        type: string
      run:
        description: "Index of the run. This is used to distinguish between multiple benchmark runs on the same commit."
        required: true
        type: number
      is_nightly:
        description: "`false` to run the benchmarks that are run on every PR merge (shorter) or `true` to run nightly benchmarks (longer)."
        required: true
        type: boolean

permissions:
  contents: read
  pull-requests: write # Needed to post comments on PRs

jobs:
  run_benchmarks:
    name: Run Benchmarks
    if: github.event_name != 'pull_request' || github.event.pull_request.merged == true
    runs-on: ["self-hosted", "benchmarks"]

    env:
      # Commit to benchmark.
      # Note: in this case, in the case of a `pull_request` even `github.sha` is
      # the merge commit.
      COMMIT: ${{ github.event_name == 'workflow_call' && github.event.inputs.commit || github.sha }}

      # PR number associated with the benchmarked commit.
      # If this is 0 the step "Find PR" will try to find the PR associated with
      # the commit.
      PR: ${{ github.event_name == 'pull_request' && github.event.pull_request.number || 0 }}

      # GitHub repository name.
      # This is always  `scala/scala3` for `pull_request` and
      # `repository_dispatch` events, but can be different for `schedule` events
      # as they allow to run the workflow on pull requests from other
      # repositories.
      REPO: ${{ github.event_name == 'workflow_call' && github.event.inputs.repo || github.repository }}

      # Index of the run.
      # Always 0 for `pull_request` and `repository_dispatch` events.
      # For `schedule` events, index of the run in a series of runs.
      RUN: ${{ github.event_name == 'workflow_call' && github.event.inputs.run || 0 }}

      # Whether to run the "merge" benchmarks or the "nightly" benchmarks.
      IS_NIGHTLY: ${{ (github.event_name == 'schedule' || github.event_name == 'workflow_call' && github.event.inputs.profile == 'nightly') }}

      # Path where to store the standard output of JMH.
      JMH_OUTPUT_PATH: jmh-output.txt

      # Shared options to pass to JMH.
      # - `-foe true` means "fail on error".
      # - `-gc true` launches the garbage collector between each iterations,
      #   which significantly reduces noise.
      JMH_ARGS: -foe true -gc true -wi 0 -i 1

      # Fully qualified path of the `@main def importResults` method.
      IMPORT_RESULTS_MAIN: dotty.tools.benchmarks.scripts.importResults

      # Fully qualified path of the `@main def aggregateData` method.
      AGGREGATE_DATA_MAIN: dotty.tools.benchmarks.scripts.aggregateData

      # Path to the directory where the benchmark data is stored on the runner.
      DATA_DIR: /home/scalabenchs/bench-data-v3

      # Destination of the benchmarks data.
      DATA_DEST: w3dtbenc@tresorvm02:htdocs/v3/data

      # Path to the directory that contains the bench visualizer app.
      VISUALIZER_DIR: bench-visualizer

      # Destination of the visualizer app.
      VISUALIZER_DEST: w3dtbenc@tresorvm02:htdocs/v3

    steps:
      - name: Find PR
        if: ${{ env.PR == '0' }}
        uses: actions/github-script@v7
        with:
          script: | #js
            const prs = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha
            });
            if (prs.data.length === 1) {
              const pr = prs.data[0].number;
              core.info(`PR associated with commit ${context.sha}: ${pr}.`);
              core.exportVariable('PR', prs.data[0].number);
            } else if (prs.data.length === 0) {
              core.warning(`Cannot find any PR associated with commit ${context.sha}.`);
            } else {
              core.warning(`Found multiple PRs associated with commit ${context.sha}: ${prs.data.map(pr => pr.number).join(', ')}.`);
            }

      - name: Check out the repository
        uses: actions/checkout@v4
        with:
          submodules: "true"
          ref: ${{ env.COMMIT }}
          repository: ${{ env.REPO }}

      # This is a workaround to make the binaries installed by `coursier` on the
      # runner's VM available in the PATH.
      - name: Set path
        run: echo '/home/scalabenchs/.local/share/coursier/bin' >> $GITHUB_PATH

      # Compilation is done as a separate step from running the benchmarks
      # simply to make the logs easier to read and to time it separately.
      - name: Compile (non-bootstrapped)
        run: sbtn "scala3-bench / Jmh / compile"

      - name: Run benchmarks (non-bootstrapped)
        env:
          # JMH filters selecting non-bootstrapped benchmarks to run.
          # `-e` means "exclude".
          JMH_FILTERS: ${{ env.IS_NIGHTLY && '-e Bootstrapped -e Nightly' || '-e Bootstrapped Nightly' }}
        run: sbtn "scala3-bench / Jmh / run $JMH_ARGS $JMH_FILTERS"

      - name: Compile (bootstrapped)
        run: echo "scala3-bench-bootstrapped / Jmh / compile"

      - name: Run benchmarks (bootstrapped)
        env:
          # JMH filters selecting bootstrapped benchmarks to run.
          JMH_BOOTSTRAPPED_FILTERS: ${{ env.IS_NIGHTLY && 'Bootstrapped -e Nightly' || 'BootstrappedNightly' }}
        run: echo "scala3-bench-bootstrapped / Jmh / run $JMH_ARGS $JMH_BOOTSTRAPPED_FILTERS"

      - name: Import results
        env:
          # Path to the CSV file in which to import the benchmark results.
          DATA_CSV_PATH: $DATA_DIR/raw/$COMMIT/${{ env.IS_NIGHTLY && 'nightly' || 'merge' }}-$RUN.csv
        run: sbtn "scala3-bench-scripts / runMain $IMPORT_RESULTS_MAIN -- $PR $COMMIT $RUN $JMH_OUTPUT_PATH $DATA_CSV_PATH"

      - name: Aggregate data
        if: ${{ github.event_name != 'workflow_call' }}
        run: sbtn "scala3-bench-scripts / runMain $AGGREGATE_DATA_MAIN -- $DATA_DIR/raw $DATA_DIR/aggregated"

      - name: Shutdown SBT
        run: sbtn shutdown

      - name: Sync data
        run: echo "rsync -av $DATA_DIR $DATA_DEST"

      # When a pull request is merged, also update the visualizer itself.
      - name: Sync visualizer
        if: github.event_name == 'pull_request'
        run: echo "rsync -av $VISUALIZER_DIR $VISUALIZER_DEST"
