name: Benchmarks

on:
  pull_request:
    types:
      - closed # Triggered when a PR is merged
  schedule:
    - cron: "11 1 * * *" # Every night at 01:11 UTC
  workflow_call:
    inputs:
      commit:
        required: true
        type: string
      repo:
        required: true
        type: string
      run:
        required: true
        type: number
      is_last_run:
        required: true
        type: boolean

permissions:
  contents: read
  pull-requests: write # Needed to post comments on PRs

env:
  # Path where to store the standard output of JMH.
  JMH_OUTPUT_PATH: jmh-output.txt

  # Fully qualified path of the `@main def importResults` method.
  IMPORT_RESULTS_MAIN: dotty.tools.benchmarks.scripts.importResults

  # Fully qualified path of the `@main def aggregateData` method.
  AGGREGATE_DATA_MAIN: dotty.tools.benchmarks.scripts.aggregateData

  # Path to the directory where the benchmark data is stored on the runner's VM.
  DATA_DIR: /home/scalabenchs/bench-data-v3

  # Destination of the benchmarks data.
  DATA_DEST: w3dtbenc@tresorvm02:htdocs/v3/data

  # Path to the directory that contains the bench visualizer app.
  VISUALIZER_DIR: bench-visualizer

  # Destination of the visualizer app.
  VISUALIZER_DEST: w3dtbenc@tresorvm02:htdocs/v3

  # Options to pass to JMH.
  # `-foe true` means "fail on error".
  # `-gc true` launches the garbage collector between each iterations, which significantly reduces noise.
  JMH_ARGS: -foe true -gc true -wi 0 -i 1

jobs:
  run_benchmarks:
    name: Run Benchmarks
    if: github.event_name != 'pull_request' || github.event.pull_request.merged == true
    runs-on: ["self-hosted", "benchmarks"]

    steps:
      - name: Print webhook payload
        if: ${{ github.event_name == 'repository_dispatch' }}
        run: echo ${{ toJson(github.event.client_payload) }}

      - name: Set environment variables
        uses: actions/github-script@v7
        with:
          script: |
            async function get_pr_for_commit(commit) {
              const prs = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                owner: context.repo.owner,
                repo: context.repo.repo,
                commit_sha: context.sha
              });
              if (prs.data.length === 1) {
                return prs.data[0].number);
              } else {
                core.warning(`Cannot find one PR associated with commit ${context.sha}: [${prs.data.map(pr => pr.number).join(', ')}]`);
                return 0;
              }
            }
            switch (context.eventName) {
              case 'pull_request':
                // Commit to benchmark.
                // Note: in this case, as the event is `pull_request` and it the
                // pull request has been merged, this is the merge commit.
                core.exportVariable('COMMIT', context.sha);

                // PR number associated with the benchmarked commit.
                core.exportVariable('PR', context.payload.pull_request.number);

                // GitHub repository name.
                // This is always  `scala/scala3` for `pull_request` and
                // `repository_dispatch` events, but can be different for
                // `schedule` events as they allow to run the workflow on pull
                // requests from other repositories.
                core.exportVariable('REPO', context.repo.repo);

                // Index of the run.
                // Always 0 for `pull_request` and `repository_dispatch` events.
                // For `schedule` events, index of the run in a series of runs.
                core.exportVariable('RUN', 0);

                // True if this is the last run of a series of runs.
                // Always true for `pull_request` and `repository_dispatch`
                // events. For `schedule` events, it is true if the run is the
                // final one in a series of runs. If this the case the
                // results of the run will be uploaded and a comment posted.
                core.exportVariable('IS_LAST_RUN', 'true');

                // `-e` means "exclude".
                // Select benchmarks that do not contain `Nightly` or `Bootstrapped` in their name.
                core.exportVariable('JMH_FILTERS', "-e Bootstrapped -e Nightly");

                // Select benchmarks that contain `Bootstrapped` in their name, but not `Nightly`.
                core.exportVariable('JMH_BOOTSTRAPPED_FILTERS', "Bootstrapped -e Nightly");

                // Results of "on-merge" and nightly runs are stored in the same file: `main.csv`.
                core.exportVariable('DATA_CSV_PATH', `${process.env.DATA_DIR}/main.csv`);
                break;
              case 'schedule':
                core.exportVariable('COMMIT', context.sha);
                core.exportVariable('PR', await get_pr_for_commit(context.sha));
                core.exportVariable('REPO', context.repo.repo);
                core.exportVariable('RUN', 0);
                core.exportVariable('IS_LAST_RUN', 'true');
                core.exportVariable('JMH_FILTERS', "-e Bootstrapped Nightly");
                core.exportVariable('JMH_BOOTSTRAPPED_FILTERS', "BootstrappedNightly");
                core.exportVariable('DATA_CSV_PATH', `${process.env.DATA_CSV_PATH}/main.csv`);
                break;
              case 'workflow_call':
                const commit = context.payload.inputs.commit;
                core.exportVariable('COMMIT', context.payload.inputs.commit);
                core.exportVariable('PR', await get_pr_for_commit(commit));
                core.exportVariable('REPO', context.payload.inputs.repo);
                core.exportVariable('RUN', context.payload.inputs.run);
                core.exportVariable('IS_LAST_RUN', context.payload.inputs.is_last_run);
                core.exportVariable('JMH_FILTERS', "-e Bootstrapped");
                core.exportVariable('JMH_BOOTSTRAPPED_FILTERS', "Bootstrapped");
                core.exportVariable('DATA_CSV_PATH', `${process.env.DATA_CSV_PATH}/manual/${commit.slice(0, 16)}.csv`);
                break;
              default:
                core.setFailed(`Unsupported event: ${github.eventName}`);
                break;

      - name: Check out the repository
        uses: actions/checkout@v4
        with:
          submodules: "true"
          ref: ${{ env.COMMIT }}
          repository: ${{ env.REPO }}

      # This is a workaround to make the binaries installed by `coursier` on the
      # runner's VM available in the PATH.
      - name: Set path
        run: echo '/home/scalabenchs/.local/share/coursier/bin' >> $GITHUB_PATH

      # Compilation is done as a separate step from running the benchmarks
      # simply to make the logs easier to read and to time it separately.
      - name: Compile Dotty (non-bootstrapped)
        run: echo "scala3-bench / Jmh / compile"

      - name: Run benchmarks (non-bootstrapped)
        run: echo "scala3-bench / Jmh / run $JMH_ARGS $JMH_FILTERS"

      - name: Compile Dotty (bootstrapped)
        run: echo "scala3-bench-bootstrapped / Jmh / compile"

      - name: Run benchmarks (bootstrapped)
        run: echo "scala3-bench-bootstrapped / Jmh / run $JMH_ARGS $JMH_BOOTSTRAPPED_FILTERS"

      - name: Import results
        run: echo "scala3-bench-scripts / runMain $IMPORT_RESULTS_MAIN -- $PR $COMMIT $RUN $JMH_OUTPUT_PATH $DATA_CSV_PATH"

      # For the `pull_request` and `schedule` events, compute the aggregated
      # data used by the visualizer.
      - name: Aggregate data
        if: github.event_name != 'repository_dispatch'
        run: echo "scala3-bench-scripts / runMain $AGGREGATE_DATA_MAIN -- $DATA_CSV_PATH $DATA_DIR/aggregated"

      - name: Sync data
        run: echo "rsync -av $DATA_DIR $DATA_DEST"

      # When a pull request is merged, also update the visualizer itself.
      - name: Sync visualizer
        if: github.event_name != 'pull_request'
        run: echo "rsync -av $VISUALIZER_DIR $VISUALIZER_DEST"

      - name: Post comment
        if: github.event_name == 'repository_dispatch' && env.IS_LAST_RUN == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const comment = `Benchmarks results ready.`;
            await github.rest.issues.createComment({
              issue_number: context.payload.client_payload.pr,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment,
            });


