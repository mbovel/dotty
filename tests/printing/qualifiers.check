[[syntax trees at end of                     typer]] // tests/printing/qualifiers.scala
package example {
  class Foo() extends Object() {
    val x:
      Int @qualified[Int](
        {
          def $anonfun(x: Int): Boolean = x.>(0)
          closure($anonfun)
        }
      )
     = 1
  }
  trait A() extends Object {}
  final lazy module val qualifiers$package: example.qualifiers$package =
    new example.qualifiers$package()
  final module class qualifiers$package() extends Object() {
    this: example.qualifiers$package.type =>
    type Neg =
      Int @qualified[Int](
        {
          def $anonfun(x: Int): Boolean = x.<(0)
          closure($anonfun)
        }
      )
    type Pos =
      Int @qualified[Int](
        {
          def $anonfun(x: Int): Boolean = x.>(0)
          closure($anonfun)
        }
      )
    type Pos2 =
      Int @qualified[Int](
        {
          def $anonfun(x: Int): Boolean = x.>(0)
          closure($anonfun)
        }
      )
    type Pos3 =
      Int @qualified[Int](
        {
          def $anonfun(x: Int): Boolean = x.>(0)
          closure($anonfun)
        }
      )
    type Pos4 =
      Int @qualified[Int](
        {
          def $anonfun(x: Int): Boolean = x.>(0)
          closure($anonfun)
        }
      )
    type Pos5 =
      Int @qualified[Int](
        {
          def $anonfun(x: Int): Boolean =
            {
              val res: Boolean = x.>(0)
              res:Boolean
            }
          closure($anonfun)
        }
      )
    type Nested =
      Int @qualified[Int](
        {
          def $anonfun(x: Int): Boolean =
            {
              val y:
                Int @qualified[Int](
                  {
                    def $anonfun(z: Int): Boolean = z.>(0)
                    closure($anonfun)
                  }
                )
               = ???
              x.>(y)
            }
          closure($anonfun)
        }
      )
    type Intersection =
      Int &
        Int @qualified[Int](
          {
            def $anonfun(x: Int): Boolean = x.>(0)
            closure($anonfun)
          }
        )
    type ValRefinement =
      Object
        {
          val x:
            Int @qualified[Int](
              {
                def $anonfun(x: Int): Boolean = x.>(0)
                closure($anonfun)
              }
            )
        }
    def id[T >: Nothing <: Any](x: T): T = x
    def test(): Unit =
      {
        val x: example.Pos = 1
        val x2:
          Int @qualified[Int](
            {
              def $anonfun(x: Int): Boolean = x.>(0)
              closure($anonfun)
            }
          )
         = 1
        val x3:
          Int @qualified[Int](
            {
              def $anonfun(x: Int): Boolean = x.>(0)
              closure($anonfun)
            }
          )
         = 1
        val x4:
          Int @qualified[Int](
            {
              def $anonfun(x: Int): Boolean = x.>(0)
              closure($anonfun)
            }
          )
         = 1
        val x5:
          Int @qualified[Int](
            {
              def $anonfun(x5: Int): Boolean = x.>(0)
              closure($anonfun)
            }
          )
         = 1
        val x6: Int =
          example.id[
            Int @qualified[Int](
              {
                def $anonfun(x: Int): Boolean = x.<(0)
                closure($anonfun)
              }
            )
          ](1).+(example.id[example.Neg](-1))
        ()
      }
    def bar(
      x:
        Int @qualified[Int](
          {
            def $anonfun(x: Int): Boolean = x.>(0)
            closure($anonfun)
          }
        )
    ): Nothing = ???
    def secondGreater1(x: Int, y: Int)(
      z:
        Int @qualified[Int](
          {
            def $anonfun(w: Int): Boolean = x.>(y)
            closure($anonfun)
          }
        )
    ): Nothing = ???
    def secondGreater2(x: Int, y: Int)(
      z:
        Int @qualified[Int](
          {
            def $anonfun(z: Int): Boolean = x.>(y)
            closure($anonfun)
          }
        )
    ): Nothing = ???
    final lazy module given val given_A: example.given_A = new example.given_A()
    final module class given_A() extends Object(), example.A {
      this: example.given_A.type =>
      val b: Boolean = false
      example.id[Boolean](true)
    }
    type T1 =
      Object
        {
          val x: Int
        }
    type T2 =
      Object
        {
          val x: Int
        }
    type T3 =
      Object
        {
          type T = Int
        }
    type T4 =
      Object
        {
          def x: Int
        }
    type T5 =
      Object
        {
          def x: Int
          def x_=(x$1: Int): _root_.scala.Unit
        }
    type T6 =
      Object
        {
          val x: Int
        }
    type T7 =
      Object
        {
          val x: Int
        }
  }
}

