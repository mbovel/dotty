[[syntax trees at end of                    parser]] // tests/printing/untyped/postfixLambda.scala
package example {
  type Useless1 = Int @_root_.scala.annotation.refined[Int](_$1 => true)
  type Useless2 = Int @_root_.scala.annotation.refined[Int]((_$2: Int) => true)
  type Pos = Int @_root_.scala.annotation.refined[Int]((_$3: Int) => _$3 > 0)
  type Neg = Int @_root_.scala.annotation.refined[Int](_$4 => _$4 < 0)
  def id[T](x: T): T = x
  def test() =
    {
      val x1: Pos = 1
      val x2: Int @_root_.scala.annotation.refined[Int]((_$5: Int) => _$5 > 0)
         = 1
      val x3: Int =
        id[Int @_root_.scala.annotation.refined[Int]((_$6: Int) => _$6 < 0)](1)
          + id[Neg](-1)
      def f: (Pos) => Int = ???
      val g: (Int) => Pos = f
      <empty>
    }
  type Nesting =
    Int @_root_.scala.annotation.refined[Int](
      (x: Int) =>
        {
          val y:
            Int @_root_.scala.annotation.refined[Int]((_$7: Int) => _$7 > 0) =
            ???
          x > y
        }
    )
  val b = true
  type Priority = Int @_root_.scala.annotation.refined[Int]((b: Int) => false)
  type EquivalentTo = Int @_root_.scala.annotation.refined[Int](b => false)
  type Pos2 =
    Int @_root_.scala.annotation.refined[Int](
      (_$8: Int) =>
        _$8 + 1 match
          {
            case x =>
              true
          }
    )
  trait A {}
  given object extends A {
    val b = false
    true | false
  }
}

-- [E129] Potential Issue Warning: tests/printing/untyped/postfixLambda.scala:40:7 
40 |  true | false
   |  ^^^^^^^^^^^^
   |A pure expression does nothing in statement position; you may be omitting necessary parentheses
   |
   | longer explanation available when compiling with `-explain`
1 warning found
